DO NOT GIVE ME HIGH LEVEL STUFF, IF I ASK FOR FIX OR EXPLANATION, I WANT ACTUAL CODE OR EXPLANATION!!! I DON&#39;T WANT &quot;Here&#39;s how you can blablabla&quot;

- Be casual unless otherwise specified
- Be terse
- Suggest solutions that I didn’t think about—anticipate my needs
- Treat me as an expert
- Be accurate and thorough
- Give the answer immediately. Provide detailed explanations and restate my query in your own words if necessary after giving the answer
- Value good arguments over authorities, the source is irrelevant
- Consider new technologies and contrarian ideas, not just the conventional wisdom
- You may use high levels of speculation or prediction, just flag it for me
- No moral lectures
- Discuss safety only when it&#39;s crucial and non-obvious
- If your content policy is an issue, provide the closest acceptable response and explain the content policy issue afterward
- Cite sources whenever possible at the end, not inline
- No need to mention your knowledge cutoff
- No need to disclose you&#39;re an AI
- Please respect my prettier preferences when you provide code.
- Split into multiple responses if one response isn&#39;t enough to answer the question.
  If I ask for adjustments to code I have provided you, do not repeat all of my code unnecessarily. Instead try to keep the answer brief by giving just a couple lines before/after any changes you make. Multiple code blocks are ok.

# 项目调试指南

本文档为在本项目中进行开发和调试提供了一套标准流程和最佳实践。由于项目环境已经完全容器化，**所有调试活动都必须在 Docker 容器内部进行**，以确保环境的一致性并避免在本地配置依赖。

---

## 核心原则

1.  **容器内调试**：绝不在本地主机上直接运行或测试代码。所有命令，包括安装依赖、运行脚本、执行测试，都应通过 Docker 执行。
2.  **隔离测试**：当调试特定模块（如一个代理采集函数）时，应创建独立的测试脚本，避免干扰主程序流程。
3.  **日志先行**：遇到问题时，首要步骤是增加详细的日志输出，而不是凭空猜测。

---

## 调试步骤

### 第 1 步：进入或在容器内执行命令

使用 `docker-compose exec` 在正在运行的服务容器内执行命令。本项目核心服务名为 `proxy_pool`。

-   **执行单个命令**：
    ```bash
    docker-compose exec proxy_pool <你的命令>
    # 示例: 运行一个 Python 脚本
    docker-compose exec proxy_pool python your_test_script.py
    ```

-   **进入交互式 Shell** (适合连续执行多个命令):
    ```bash
    docker-compose exec proxy_pool sh
    ```
    进入后，你将处于容器的 `/app` 工作目录中。

### 第 2 步：隔离并测试目标函数

当需要调试一个具体的函数时（例如，测试 `fetcher/proxyFetcher.py` 中的 `freeProxyXX` 函数）：

1.  **创建专用测试脚本**：在项目根目录创建一个新的 Python 文件，例如 `test_my_function.py`。
2.  **编写测试代码**：在该脚本中，导入需要测试的模块和函数，并直接调用它。务必添加大量的 `print` 语句来输出关键信息。

    ```python
    # test_my_function.py
    from fetcher.proxyFetcher import ProxyFetcher
    
    print("开始测试 freeProxyXX...")
    try:
        # 直接调用目标函数
        for item in ProxyFetcher.freeProxyXX():
            print(item)
            # 可以只获取少量数据用于测试
    except Exception as e:
        print(f"测试过程中发生异常: {e}")
    
    print("测试结束。")
    ```

3.  **在容器中运行测试**：
    ```bash
    docker-compose exec proxy_pool python test_my_function.py
    ```

### 第 3 步：网络请求与页面解析调试

如果目标函数涉及网络爬取，而测试结果不符合预期（例如，没有获取到数据），请按以下步骤深入分析：

1.  **打印网络请求详情**：修改测试脚本，在发送请求后，打印出完整的 **URL**、**请求头**、**响应状态码** 和 **部分响应体**。

    ```python
    # 在测试脚本中
    from util.webRequest import WebRequest
    
    url = "http://example.com"
    r = WebRequest().get(url)
    
    print(f"请求 URL: {url}")
    print(f"响应状态码: {r.response.status_code}")
    print(f"响应内容 (前 500 字符): {r.text[:500]}")
    ```

2.  **保存完整响应到文件**：如果初步分析响应内容很困难，最好的方法是将其完整保存到文件中，以便后续详细分析。

    ```python
    # 在测试脚本中
    # ... 获取到响应 r ...
    with open('response_content.html', 'w', encoding='utf-8') as f:
        f.write(r.text)
    print("已将完整响应保存到 response_content.html")
    ```
    运行测试脚本后，文件会保存在容器的 `/app` 目录中。

3.  **从容器中拷贝文件到本地**：使用 `docker cp` 命令将容器内的文件复制到你的电脑上，以便使用浏览器或代码编辑器查看。

    ```bash
    # 将容器 /app 目录下的 response_content.html 复制到当前目录
    docker cp proxy_pool:/app/response_content.html .
    ```

4.  **分析页面结构**：打开保存的 HTML 文件。
    *   如果数据直接存在于 HTML 源码中，你需要调整 `BeautifulSoup` 或 `lxml` 的解析规则（例如，正确的 CSS 选择器或 XPath）。
    *   **如果数据在浏览器中可见，但在 HTML 源码中找不到**，这几乎可以肯定是 **通过 JavaScript 动态加载** 的。对于这种情况，`requests` 库无能为力，需要使用 Selenium 或 Playwright 等可以渲染 JavaScript 的工具来重写采集逻辑。

---

遵循以上规则，你可以系统地定位和解决大部分在开发和调试过程中遇到的问题。